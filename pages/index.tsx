import type { NextPage } from 'next'
import Head from 'next/head'
import Link from 'next/link'
import { useEffect, useState } from 'react'

export const DEFAULT_CACHE = 20

function makeid(length: number) {
  var result = ''
  var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
  var charactersLength = characters.length
  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength))
  }
  return result
}

const PAGE_ID_KEY = 'pageId'
export const DEFAULT_SLEEP = 2000
const Home: NextPage = () => {
  const [pageId, setPageId] = useState<string>('random')

  useEffect(() => {
    const id = localStorage.getItem(PAGE_ID_KEY) || 'random'
    setPageId(id)
  }, [])

  useEffect(() => {
    if (pageId === 'random') return
    localStorage.setItem(PAGE_ID_KEY, pageId)
  }, [pageId])

  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>
      <section>
        <div>
          <p>
            Page ID: <strong>{pageId}</strong>
          </p>
          <button
            onClick={() => {
              setPageId(makeid(5))
            }}
          >
            Generate new ID
          </button>
          <input type='text' value={pageId} onChange={(e) => setPageId(e.target.value)} />
        </div>

        <div style={pageId ? {} : { pointerEvents: 'none', opacity: 0.3 }}>
          <h2>Server Site Rendered</h2>
          <p>
            Server Side Render will run on every page navigation, for every user, but as we can set a cache on response,
            a user can get a 304(NOT CHANGED) response from server when opening a still cached content.
          </p>
          <p>
            But even if a user open a content, and right after that another user tries to open the same URL, it won`t be
            cached for the second user, as this cache is per browser
          </p>
          <p>
            CONS: Everyone will have a delay on first time opening an URL (even Google); SSR response isn`t reused for
            different users
          </p>
          <p>
            <a href='https://vercel.com/docs/concepts/edge-network/caching#stale-while-revalidate'>
              https://vercel.com/docs/concepts/edge-network/caching#stale-while-revalidate
            </a>
          </p>
          <ul>
            <li>
              <Link href={`/ssr/not-cached/ssr-not-chached-${pageId}`} prefetch={false}>
                <a>Without Cache</a>
              </Link>
            </li>
            <li>
              <Link href={`/ssr/cached/ssr-cached-stale-${pageId}`} prefetch={false}>
                <a>With Cache {DEFAULT_CACHE}sec</a>
              </Link>
            </li>
            <li>
              <Link href={`/ssr/cached/not-stale/ssr-cached-not-stale-${pageId}`} prefetch={false}>
                <a>With Cache {DEFAULT_CACHE}sec (not stale)</a>
              </Link>
            </li>
          </ul>
          <hr />
          <h2>Static Site Generated</h2>
          <p>Static Site Genaretion takes place on build and when someone opens one url for the first time.</p>
          <p>
            So when a user hits one URL we can decide to return empty props while fetching that data on Background, or
            block the user just like it happens for SSR.
          </p>
          <p>
            After caching the result for a page, everyone hitting the same URL will receive the cached data, and when
            someone hits one outdated cache, it will be revalidated for the next attempt on that URL
          </p>
          <p>
            CONS: NextJS will always run prefetch when hovering urls, which will trigger a lot of lambda calls; NextJS
            needs to use some cache space on
          </p>
          <p>
            <a href='https://vercel.com/docs/concepts/next.js/incremental-static-regeneration'>
              https://vercel.com/docs/concepts/next.js/incremental-static-regeneration#on-demand-revalidation
            </a>
          </p>
          <ul>
            <li>
              <Link href={`/ssg/fallback/ssg-fallback-${pageId}`} prefetch={false}>
                <a>With Fallback</a>
              </Link>
            </li>
            <li>
              <Link href={`/ssg/not-fallback/ssg-not-fallback-${pageId}`} prefetch={false}>
                <a>Without Fallback</a>
              </Link>
            </li>
            <li>
              <Link href={`/ssg/blocking/ssg-blocking-${pageId}`} prefetch={false}>
                <a>With Blocking</a>
              </Link>
            </li>
          </ul>
        </div>
      </section>
    </>
  )
}

export default Home
